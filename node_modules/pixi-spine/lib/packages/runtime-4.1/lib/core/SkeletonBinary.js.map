{"version":3,"file":"SkeletonBinary.js","sources":["../../../../../../../packages/runtime-4.1/lib/core/SkeletonBinary.mjs"],"sourcesContent":["import { AlphaTimeline, RGB2Timeline, RGBA2Timeline, RGBTimeline, RGBATimeline, AttachmentTimeline, ShearYTimeline, ShearXTimeline, ShearTimeline, ScaleYTimeline, ScaleXTimeline, ScaleTimeline, TranslateYTimeline, TranslateXTimeline, TranslateTimeline, RotateTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintMixTimeline, PathConstraintSpacingTimeline, PathConstraintPositionTimeline, SequenceTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, Animation } from './Animation.mjs';\nimport { Event } from './Event.mjs';\nimport { SkeletonData } from './SkeletonData.mjs';\nimport { SlotData } from './SlotData.mjs';\nimport { BoneData } from './BoneData.mjs';\nimport { IkConstraintData } from './IkConstraintData.mjs';\nimport { TransformConstraintData } from './TransformConstraintData.mjs';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData.mjs';\nimport { Skin } from './Skin.mjs';\nimport { EventData } from './EventData.mjs';\nimport { BinaryInput, Color, PositionMode, Utils, AttachmentType } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/constants';\nimport './attachments/Attachment.mjs';\nimport './attachments/RegionAttachment.mjs';\nimport { Sequence, SequenceModeValues } from './attachments/Sequence.mjs';\n\nclass SkeletonBinary {\n  constructor(attachmentLoader) {\n    this.ver40 = false;\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n     * runtime than were used in Spine.\n     *\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n    this.scale = 1;\n    this.linkedMeshes = new Array();\n    this.attachmentLoader = attachmentLoader;\n  }\n  readSkeletonData(binary) {\n    const scale = this.scale;\n    const skeletonData = new SkeletonData();\n    skeletonData.name = \"\";\n    const input = new BinaryInput(binary);\n    const lowHash = input.readInt32();\n    const highHash = input.readInt32();\n    skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);\n    skeletonData.version = input.readString();\n    const verShort = skeletonData.version.substr(0, 3);\n    if (verShort !== \"4.0\" && verShort !== \"4.1\") {\n      const error = `Spine 4.1 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;\n      console.error(error);\n    }\n    this.ver40 = verShort === \"4.0\";\n    skeletonData.x = input.readFloat();\n    skeletonData.y = input.readFloat();\n    skeletonData.width = input.readFloat();\n    skeletonData.height = input.readFloat();\n    const nonessential = input.readBoolean();\n    if (nonessential) {\n      skeletonData.fps = input.readFloat();\n      skeletonData.imagesPath = input.readString();\n      skeletonData.audioPath = input.readString();\n    }\n    let n = 0;\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const str = input.readString();\n      if (!str)\n        throw new Error(\"String in string table must not be null.\");\n      input.strings.push(str);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const name = input.readString();\n      if (!name)\n        throw new Error(\"Bone name must not be null.\");\n      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n      const data = new BoneData(i, name, parent);\n      data.rotation = input.readFloat();\n      data.x = input.readFloat() * scale;\n      data.y = input.readFloat() * scale;\n      data.scaleX = input.readFloat();\n      data.scaleY = input.readFloat();\n      data.shearX = input.readFloat();\n      data.shearY = input.readFloat();\n      data.length = input.readFloat() * scale;\n      data.transformMode = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      if (nonessential)\n        Color.rgba8888ToColor(data.color, input.readInt32());\n      skeletonData.bones.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const slotName = input.readString();\n      if (!slotName)\n        throw new Error(\"Slot name must not be null.\");\n      const boneData = skeletonData.bones[input.readInt(true)];\n      const data = new SlotData(i, slotName, boneData);\n      Color.rgba8888ToColor(data.color, input.readInt32());\n      const darkColor = input.readInt32();\n      if (darkColor != -1)\n        Color.rgb888ToColor(data.darkColor = new Color(), darkColor);\n      data.attachmentName = input.readStringRef();\n      data.blendMode = input.readInt(true);\n      skeletonData.slots.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      if (!name)\n        throw new Error(\"IK constraint data name must not be null.\");\n      const data = new IkConstraintData(name);\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++)\n        data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.mix = input.readFloat();\n      data.softness = input.readFloat() * scale;\n      data.bendDirection = input.readByte();\n      data.compress = input.readBoolean();\n      data.stretch = input.readBoolean();\n      data.uniform = input.readBoolean();\n      skeletonData.ikConstraints.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      if (!name)\n        throw new Error(\"Transform constraint data name must not be null.\");\n      const data = new TransformConstraintData(name);\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++)\n        data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.local = input.readBoolean();\n      data.relative = input.readBoolean();\n      data.offsetRotation = input.readFloat();\n      data.offsetX = input.readFloat() * scale;\n      data.offsetY = input.readFloat() * scale;\n      data.offsetScaleX = input.readFloat();\n      data.offsetScaleY = input.readFloat();\n      data.offsetShearY = input.readFloat();\n      data.mixRotate = input.readFloat();\n      data.mixX = input.readFloat();\n      data.mixY = input.readFloat();\n      data.mixScaleX = input.readFloat();\n      data.mixScaleY = input.readFloat();\n      data.mixShearY = input.readFloat();\n      skeletonData.transformConstraints.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      if (!name)\n        throw new Error(\"Path constraint data name must not be null.\");\n      const data = new PathConstraintData(name);\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++)\n        data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.slots[input.readInt(true)];\n      data.positionMode = input.readInt(true);\n      data.spacingMode = input.readInt(true);\n      data.rotateMode = input.readInt(true);\n      data.offsetRotation = input.readFloat();\n      data.position = input.readFloat();\n      if (data.positionMode == PositionMode.Fixed)\n        data.position *= scale;\n      data.spacing = input.readFloat();\n      if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed)\n        data.spacing *= scale;\n      data.mixRotate = input.readFloat();\n      data.mixX = input.readFloat();\n      data.mixY = input.readFloat();\n      skeletonData.pathConstraints.push(data);\n    }\n    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n    if (defaultSkin) {\n      skeletonData.defaultSkin = defaultSkin;\n      skeletonData.skins.push(defaultSkin);\n    }\n    {\n      let i = skeletonData.skins.length;\n      Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\n      for (; i < n; i++) {\n        const skin = this.readSkin(input, skeletonData, false, nonessential);\n        if (!skin)\n          throw new Error(\"readSkin() should not have returned null.\");\n        skeletonData.skins[i] = skin;\n      }\n    }\n    n = this.linkedMeshes.length;\n    for (let i = 0; i < n; i++) {\n      const linkedMesh = this.linkedMeshes[i];\n      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      if (!skin)\n        throw new Error(\"Not skin found for linked mesh.\");\n      if (!linkedMesh.parent)\n        throw new Error(\"Linked mesh parent must not be null\");\n      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      if (!parent)\n        throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(parent);\n    }\n    this.linkedMeshes.length = 0;\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const eventName = input.readStringRef();\n      if (!eventName)\n        throw new Error();\n      const data = new EventData(eventName);\n      data.intValue = input.readInt(false);\n      data.floatValue = input.readFloat();\n      data.stringValue = input.readString();\n      data.audioPath = input.readString();\n      if (data.audioPath) {\n        data.volume = input.readFloat();\n        data.balance = input.readFloat();\n      }\n      skeletonData.events.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const animationName = input.readString();\n      if (!animationName)\n        throw new Error(\"Animatio name must not be null.\");\n      skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));\n    }\n    return skeletonData;\n  }\n  readSkin(input, skeletonData, defaultSkin, nonessential) {\n    let skin = null;\n    let slotCount = 0;\n    if (defaultSkin) {\n      slotCount = input.readInt(true);\n      if (slotCount == 0)\n        return null;\n      skin = new Skin(\"default\");\n    } else {\n      const skinName = input.readStringRef();\n      if (!skinName)\n        throw new Error(\"Skin name must not be null.\");\n      skin = new Skin(skinName);\n      skin.bones.length = input.readInt(true);\n      for (let i = 0, n = skin.bones.length; i < n; i++)\n        skin.bones[i] = skeletonData.bones[input.readInt(true)];\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n      for (let i = 0, n = input.readInt(true); i < n; i++)\n        skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n      slotCount = input.readInt(true);\n    }\n    for (let i = 0; i < slotCount; i++) {\n      const slotIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const name = input.readStringRef();\n        if (!name)\n          throw new Error(\"Attachment name must not be null\");\n        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n        if (attachment)\n          skin.setAttachment(slotIndex, name, attachment);\n      }\n    }\n    return skin;\n  }\n  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {\n    const scale = this.scale;\n    let name = input.readStringRef();\n    if (!name)\n      name = attachmentName;\n    switch (input.readByte()) {\n      case AttachmentType.Region: {\n        let path = input.readStringRef();\n        const rotation = input.readFloat();\n        const x = input.readFloat();\n        const y = input.readFloat();\n        const scaleX = input.readFloat();\n        const scaleY = input.readFloat();\n        const width = input.readFloat();\n        const height = input.readFloat();\n        const color = input.readInt32();\n        const sequence = this.readSequence(input);\n        if (!path)\n          path = name;\n        const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n        if (!region)\n          return null;\n        region.path = path;\n        region.x = x * scale;\n        region.y = y * scale;\n        region.scaleX = scaleX;\n        region.scaleY = scaleY;\n        region.rotation = rotation;\n        region.width = width * scale;\n        region.height = height * scale;\n        Color.rgba8888ToColor(region.color, color);\n        region.sequence = sequence;\n        if (sequence == null)\n          region.updateRegion();\n        return region;\n      }\n      case AttachmentType.BoundingBox: {\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const color = nonessential ? input.readInt32() : 0;\n        const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n        if (!box)\n          return null;\n        box.worldVerticesLength = vertexCount << 1;\n        box.vertices = vertices.vertices;\n        box.bones = vertices.bones;\n        if (nonessential)\n          Color.rgba8888ToColor(box.color, color);\n        return box;\n      }\n      case AttachmentType.Mesh: {\n        let path = input.readStringRef();\n        const color = input.readInt32();\n        const vertexCount = input.readInt(true);\n        const uvs = this.readFloatArray(input, vertexCount << 1, 1);\n        const triangles = this.readShortArray(input);\n        const vertices = this.readVertices(input, vertexCount);\n        const hullLength = input.readInt(true);\n        const sequence = this.readSequence(input);\n        let edges = [];\n        let width = 0;\n        let height = 0;\n        if (nonessential) {\n          edges = this.readShortArray(input);\n          width = input.readFloat();\n          height = input.readFloat();\n        }\n        if (!path)\n          path = name;\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n        if (!mesh)\n          return null;\n        mesh.path = path;\n        Color.rgba8888ToColor(mesh.color, color);\n        mesh.bones = vertices.bones;\n        mesh.vertices = vertices.vertices;\n        mesh.worldVerticesLength = vertexCount << 1;\n        mesh.triangles = triangles;\n        mesh.regionUVs = new Float32Array(uvs);\n        mesh.hullLength = hullLength << 1;\n        mesh.sequence = sequence;\n        if (nonessential) {\n          mesh.edges = edges;\n          mesh.width = width * scale;\n          mesh.height = height * scale;\n        }\n        return mesh;\n      }\n      case AttachmentType.LinkedMesh: {\n        let path = input.readStringRef();\n        const color = input.readInt32();\n        const skinName = input.readStringRef();\n        const parent = input.readStringRef();\n        const inheritTimelines = input.readBoolean();\n        const sequence = this.readSequence(input);\n        let width = 0;\n        let height = 0;\n        if (nonessential) {\n          width = input.readFloat();\n          height = input.readFloat();\n        }\n        if (!path)\n          path = name;\n        const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n        if (!mesh)\n          return null;\n        mesh.path = path;\n        Color.rgba8888ToColor(mesh.color, color);\n        mesh.sequence = sequence;\n        if (nonessential) {\n          mesh.width = width * scale;\n          mesh.height = height * scale;\n        }\n        this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritTimelines));\n        return mesh;\n      }\n      case AttachmentType.Path: {\n        const closed = input.readBoolean();\n        const constantSpeed = input.readBoolean();\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const lengths = Utils.newArray(vertexCount / 3, 0);\n        for (let i = 0, n = lengths.length; i < n; i++)\n          lengths[i] = input.readFloat() * scale;\n        const color = nonessential ? input.readInt32() : 0;\n        const path = this.attachmentLoader.newPathAttachment(skin, name);\n        if (!path)\n          return null;\n        path.closed = closed;\n        path.constantSpeed = constantSpeed;\n        path.worldVerticesLength = vertexCount << 1;\n        path.vertices = vertices.vertices;\n        path.bones = vertices.bones;\n        path.lengths = lengths;\n        if (nonessential)\n          Color.rgba8888ToColor(path.color, color);\n        return path;\n      }\n      case AttachmentType.Point: {\n        const rotation = input.readFloat();\n        const x = input.readFloat();\n        const y = input.readFloat();\n        const color = nonessential ? input.readInt32() : 0;\n        const point = this.attachmentLoader.newPointAttachment(skin, name);\n        if (!point)\n          return null;\n        point.x = x * scale;\n        point.y = y * scale;\n        point.rotation = rotation;\n        if (nonessential)\n          Color.rgba8888ToColor(point.color, color);\n        return point;\n      }\n      case AttachmentType.Clipping: {\n        const endSlotIndex = input.readInt(true);\n        const vertexCount = input.readInt(true);\n        const vertices = this.readVertices(input, vertexCount);\n        const color = nonessential ? input.readInt32() : 0;\n        const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n        if (!clip)\n          return null;\n        clip.endSlot = skeletonData.slots[endSlotIndex];\n        clip.worldVerticesLength = vertexCount << 1;\n        clip.vertices = vertices.vertices;\n        clip.bones = vertices.bones;\n        if (nonessential)\n          Color.rgba8888ToColor(clip.color, color);\n        return clip;\n      }\n    }\n    return null;\n  }\n  readSequence(input) {\n    if (this.ver40 || !input.readBoolean())\n      return null;\n    const sequence = new Sequence(input.readInt(true));\n    sequence.start = input.readInt(true);\n    sequence.digits = input.readInt(true);\n    sequence.setupIndex = input.readInt(true);\n    return sequence;\n  }\n  readDeformTimelineType(input) {\n    if (this.ver40)\n      return ATTACHMENT_DEFORM;\n    return input.readByte();\n  }\n  readVertices(input, vertexCount) {\n    const scale = this.scale;\n    const verticesLength = vertexCount << 1;\n    const vertices = new Vertices();\n    if (!input.readBoolean()) {\n      vertices.vertices = this.readFloatArray(input, verticesLength, scale);\n      return vertices;\n    }\n    const weights = new Array();\n    const bonesArray = new Array();\n    for (let i = 0; i < vertexCount; i++) {\n      const boneCount = input.readInt(true);\n      bonesArray.push(boneCount);\n      for (let ii = 0; ii < boneCount; ii++) {\n        bonesArray.push(input.readInt(true));\n        weights.push(input.readFloat() * scale);\n        weights.push(input.readFloat() * scale);\n        weights.push(input.readFloat());\n      }\n    }\n    vertices.vertices = Utils.toFloatArray(weights);\n    vertices.bones = bonesArray;\n    return vertices;\n  }\n  readFloatArray(input, n, scale) {\n    const array = new Array(n);\n    if (scale == 1) {\n      for (let i = 0; i < n; i++)\n        array[i] = input.readFloat();\n    } else {\n      for (let i = 0; i < n; i++)\n        array[i] = input.readFloat() * scale;\n    }\n    return array;\n  }\n  readShortArray(input) {\n    const n = input.readInt(true);\n    const array = new Array(n);\n    for (let i = 0; i < n; i++)\n      array[i] = input.readShort();\n    return array;\n  }\n  readAnimation(input, name, skeletonData) {\n    input.readInt(true);\n    const timelines = new Array();\n    const scale = this.scale;\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const slotIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const timelineType = input.readByte();\n        const frameCount = input.readInt(true);\n        const frameLast = frameCount - 1;\n        switch (timelineType) {\n          case SLOT_ATTACHMENT: {\n            const timeline = new AttachmentTimeline(frameCount, slotIndex);\n            for (let frame = 0; frame < frameCount; frame++)\n              timeline.setFrame(frame, input.readFloat(), input.readStringRef());\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_RGBA: {\n            const bezierCount = input.readInt(true);\n            const timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);\n            let time = input.readFloat();\n            let r = input.readUnsignedByte() / 255;\n            let g = input.readUnsignedByte() / 255;\n            let b = input.readUnsignedByte() / 255;\n            let a = input.readUnsignedByte() / 255;\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, r, g, b, a);\n              if (frame == frameLast)\n                break;\n              const time2 = input.readFloat();\n              const r2 = input.readUnsignedByte() / 255;\n              const g2 = input.readUnsignedByte() / 255;\n              const b2 = input.readUnsignedByte() / 255;\n              const a2 = input.readUnsignedByte() / 255;\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);\n              }\n              time = time2;\n              r = r2;\n              g = g2;\n              b = b2;\n              a = a2;\n            }\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_RGB: {\n            const bezierCount = input.readInt(true);\n            const timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);\n            let time = input.readFloat();\n            let r = input.readUnsignedByte() / 255;\n            let g = input.readUnsignedByte() / 255;\n            let b = input.readUnsignedByte() / 255;\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, r, g, b);\n              if (frame == frameLast)\n                break;\n              const time2 = input.readFloat();\n              const r2 = input.readUnsignedByte() / 255;\n              const g2 = input.readUnsignedByte() / 255;\n              const b2 = input.readUnsignedByte() / 255;\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n              }\n              time = time2;\n              r = r2;\n              g = g2;\n              b = b2;\n            }\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_RGBA2: {\n            const bezierCount = input.readInt(true);\n            const timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);\n            let time = input.readFloat();\n            let r = input.readUnsignedByte() / 255;\n            let g = input.readUnsignedByte() / 255;\n            let b = input.readUnsignedByte() / 255;\n            let a = input.readUnsignedByte() / 255;\n            let r2 = input.readUnsignedByte() / 255;\n            let g2 = input.readUnsignedByte() / 255;\n            let b2 = input.readUnsignedByte() / 255;\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);\n              if (frame == frameLast)\n                break;\n              const time2 = input.readFloat();\n              const nr = input.readUnsignedByte() / 255;\n              const ng = input.readUnsignedByte() / 255;\n              const nb = input.readUnsignedByte() / 255;\n              const na = input.readUnsignedByte() / 255;\n              const nr2 = input.readUnsignedByte() / 255;\n              const ng2 = input.readUnsignedByte() / 255;\n              const nb2 = input.readUnsignedByte() / 255;\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                  setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);\n                  setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);\n                  setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);\n                  setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);\n              }\n              time = time2;\n              r = nr;\n              g = ng;\n              b = nb;\n              a = na;\n              r2 = nr2;\n              g2 = ng2;\n              b2 = nb2;\n            }\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_RGB2: {\n            const bezierCount = input.readInt(true);\n            const timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);\n            let time = input.readFloat();\n            let r = input.readUnsignedByte() / 255;\n            let g = input.readUnsignedByte() / 255;\n            let b = input.readUnsignedByte() / 255;\n            let r2 = input.readUnsignedByte() / 255;\n            let g2 = input.readUnsignedByte() / 255;\n            let b2 = input.readUnsignedByte() / 255;\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, r, g, b, r2, g2, b2);\n              if (frame == frameLast)\n                break;\n              const time2 = input.readFloat();\n              const nr = input.readUnsignedByte() / 255;\n              const ng = input.readUnsignedByte() / 255;\n              const nb = input.readUnsignedByte() / 255;\n              const nr2 = input.readUnsignedByte() / 255;\n              const ng2 = input.readUnsignedByte() / 255;\n              const nb2 = input.readUnsignedByte() / 255;\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                  setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);\n                  setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);\n                  setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);\n              }\n              time = time2;\n              r = nr;\n              g = ng;\n              b = nb;\n              r2 = nr2;\n              g2 = ng2;\n              b2 = nb2;\n            }\n            timelines.push(timeline);\n            break;\n          }\n          case SLOT_ALPHA: {\n            const timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);\n            let time = input.readFloat();\n            let a = input.readUnsignedByte() / 255;\n            for (let frame = 0, bezier = 0; ; frame++) {\n              timeline.setFrame(frame, time, a);\n              if (frame == frameLast)\n                break;\n              const time2 = input.readFloat();\n              const a2 = input.readUnsignedByte() / 255;\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);\n              }\n              time = time2;\n              a = a2;\n            }\n            timelines.push(timeline);\n          }\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const boneIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const type = input.readByte();\n        const frameCount = input.readInt(true);\n        const bezierCount = input.readInt(true);\n        switch (type) {\n          case BONE_ROTATE:\n            timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_TRANSLATE:\n            timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n          case BONE_TRANSLATEX:\n            timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n          case BONE_TRANSLATEY:\n            timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n          case BONE_SCALE:\n            timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SCALEX:\n            timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SCALEY:\n            timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SHEAR:\n            timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SHEARX:\n            timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SHEARY:\n            timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const frameCount = input.readInt(true);\n      const frameLast = frameCount - 1;\n      const timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);\n      let time = input.readFloat();\n      let mix = input.readFloat();\n      let softness = input.readFloat() * scale;\n      for (let frame = 0, bezier = 0; ; frame++) {\n        timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());\n        if (frame == frameLast)\n          break;\n        const time2 = input.readFloat();\n        const mix2 = input.readFloat();\n        const softness2 = input.readFloat() * scale;\n        switch (input.readByte()) {\n          case CURVE_STEPPED:\n            timeline.setStepped(frame);\n            break;\n          case CURVE_BEZIER:\n            setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);\n            setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);\n        }\n        time = time2;\n        mix = mix2;\n        softness = softness2;\n      }\n      timelines.push(timeline);\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const frameCount = input.readInt(true);\n      const frameLast = frameCount - 1;\n      const timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);\n      let time = input.readFloat();\n      let mixRotate = input.readFloat();\n      let mixX = input.readFloat();\n      let mixY = input.readFloat();\n      let mixScaleX = input.readFloat();\n      let mixScaleY = input.readFloat();\n      let mixShearY = input.readFloat();\n      for (let frame = 0, bezier = 0; ; frame++) {\n        timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n        if (frame == frameLast)\n          break;\n        const time2 = input.readFloat();\n        const mixRotate2 = input.readFloat();\n        const mixX2 = input.readFloat();\n        const mixY2 = input.readFloat();\n        const mixScaleX2 = input.readFloat();\n        const mixScaleY2 = input.readFloat();\n        const mixShearY2 = input.readFloat();\n        switch (input.readByte()) {\n          case CURVE_STEPPED:\n            timeline.setStepped(frame);\n            break;\n          case CURVE_BEZIER:\n            setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n            setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n            setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n            setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n            setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n            setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n        }\n        time = time2;\n        mixRotate = mixRotate2;\n        mixX = mixX2;\n        mixY = mixY2;\n        mixScaleX = mixScaleX2;\n        mixScaleY = mixScaleY2;\n        mixShearY = mixShearY2;\n      }\n      timelines.push(timeline);\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const data = skeletonData.pathConstraints[index];\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        switch (input.readByte()) {\n          case PATH_POSITION:\n            timelines.push(\n              readTimeline1(\n                input,\n                new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index),\n                data.positionMode == PositionMode.Fixed ? scale : 1\n              )\n            );\n            break;\n          case PATH_SPACING:\n            timelines.push(\n              readTimeline1(\n                input,\n                new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index),\n                data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1\n              )\n            );\n            break;\n          case PATH_MIX:\n            const timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);\n            let time = input.readFloat();\n            let mixRotate = input.readFloat();\n            let mixX = input.readFloat();\n            let mixY = input.readFloat();\n            for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n              timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n              if (frame == frameLast)\n                break;\n              const time2 = input.readFloat();\n              const mixRotate2 = input.readFloat();\n              const mixX2 = input.readFloat();\n              const mixY2 = input.readFloat();\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n              }\n              time = time2;\n              mixRotate = mixRotate2;\n              mixX = mixX2;\n              mixY = mixY2;\n            }\n            timelines.push(timeline);\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const skin = skeletonData.skins[input.readInt(true)];\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const slotIndex = input.readInt(true);\n        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n          const attachmentName = input.readStringRef();\n          if (!attachmentName)\n            throw new Error(\"attachmentName must not be null.\");\n          const attachment = skin.getAttachment(slotIndex, attachmentName);\n          const timelineType = this.readDeformTimelineType(input);\n          const frameCount = input.readInt(true);\n          const frameLast = frameCount - 1;\n          switch (timelineType) {\n            case ATTACHMENT_DEFORM: {\n              const vertexAttachment = attachment;\n              const weighted = vertexAttachment.bones;\n              const vertices = vertexAttachment.vertices;\n              const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n              const bezierCount = input.readInt(true);\n              const timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);\n              let time = input.readFloat();\n              for (let frame = 0, bezier = 0; ; frame++) {\n                let deform;\n                let end = input.readInt(true);\n                if (end == 0)\n                  deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                else {\n                  deform = Utils.newFloatArray(deformLength);\n                  const start = input.readInt(true);\n                  end += start;\n                  if (scale == 1) {\n                    for (let v = start; v < end; v++)\n                      deform[v] = input.readFloat();\n                  } else {\n                    for (let v = start; v < end; v++)\n                      deform[v] = input.readFloat() * scale;\n                  }\n                  if (!weighted) {\n                    for (let v = 0, vn = deform.length; v < vn; v++)\n                      deform[v] += vertices[v];\n                  }\n                }\n                timeline.setFrame(frame, time, deform);\n                if (frame == frameLast)\n                  break;\n                const time2 = input.readFloat();\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);\n                }\n                time = time2;\n              }\n              timelines.push(timeline);\n              break;\n            }\n            case ATTACHMENT_SEQUENCE: {\n              const timeline = new SequenceTimeline(frameCount, slotIndex, attachment);\n              for (let frame = 0; frame < frameCount; frame++) {\n                const time = input.readFloat();\n                const modeAndIndex = input.readInt32();\n                timeline.setFrame(frame, time, SequenceModeValues[modeAndIndex & 15], modeAndIndex >> 4, input.readFloat());\n              }\n              timelines.push(timeline);\n              break;\n            }\n          }\n        }\n      }\n    }\n    const drawOrderCount = input.readInt(true);\n    if (drawOrderCount > 0) {\n      const timeline = new DrawOrderTimeline(drawOrderCount);\n      const slotCount = skeletonData.slots.length;\n      for (let i = 0; i < drawOrderCount; i++) {\n        const time = input.readFloat();\n        const offsetCount = input.readInt(true);\n        const drawOrder = Utils.newArray(slotCount, 0);\n        for (let ii = slotCount - 1; ii >= 0; ii--)\n          drawOrder[ii] = -1;\n        const unchanged = Utils.newArray(slotCount - offsetCount, 0);\n        let originalIndex = 0;\n        let unchangedIndex = 0;\n        for (let ii = 0; ii < offsetCount; ii++) {\n          const slotIndex = input.readInt(true);\n          while (originalIndex != slotIndex)\n            unchanged[unchangedIndex++] = originalIndex++;\n          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n        }\n        while (originalIndex < slotCount)\n          unchanged[unchangedIndex++] = originalIndex++;\n        for (let ii = slotCount - 1; ii >= 0; ii--)\n          if (drawOrder[ii] == -1)\n            drawOrder[ii] = unchanged[--unchangedIndex];\n        timeline.setFrame(i, time, drawOrder);\n      }\n      timelines.push(timeline);\n    }\n    const eventCount = input.readInt(true);\n    if (eventCount > 0) {\n      const timeline = new EventTimeline(eventCount);\n      for (let i = 0; i < eventCount; i++) {\n        const time = input.readFloat();\n        const eventData = skeletonData.events[input.readInt(true)];\n        const event = new Event(time, eventData);\n        event.intValue = input.readInt(false);\n        event.floatValue = input.readFloat();\n        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n        if (event.data.audioPath) {\n          event.volume = input.readFloat();\n          event.balance = input.readFloat();\n        }\n        timeline.setFrame(i, event);\n      }\n      timelines.push(timeline);\n    }\n    let duration = 0;\n    for (let i = 0, n = timelines.length; i < n; i++)\n      duration = Math.max(duration, timelines[i].getDuration());\n    return new Animation(name, timelines, duration);\n  }\n}\nSkeletonBinary.BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\nclass LinkedMesh {\n  constructor(mesh, skin, slotIndex, parent, inheritDeform) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritTimeline = inheritDeform;\n  }\n}\nclass Vertices {\n  constructor(bones = null, vertices = null) {\n    this.bones = bones;\n    this.vertices = vertices;\n  }\n}\nfunction readTimeline1(input, timeline, scale) {\n  let time = input.readFloat();\n  let value = input.readFloat() * scale;\n  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n    timeline.setFrame(frame, time, value);\n    if (frame == frameLast)\n      break;\n    const time2 = input.readFloat();\n    const value2 = input.readFloat() * scale;\n    switch (input.readByte()) {\n      case CURVE_STEPPED:\n        timeline.setStepped(frame);\n        break;\n      case CURVE_BEZIER:\n        setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);\n    }\n    time = time2;\n    value = value2;\n  }\n  return timeline;\n}\nfunction readTimeline2(input, timeline, scale) {\n  let time = input.readFloat();\n  let value1 = input.readFloat() * scale;\n  let value2 = input.readFloat() * scale;\n  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n    timeline.setFrame(frame, time, value1, value2);\n    if (frame == frameLast)\n      break;\n    const time2 = input.readFloat();\n    const nvalue1 = input.readFloat() * scale;\n    const nvalue2 = input.readFloat() * scale;\n    switch (input.readByte()) {\n      case CURVE_STEPPED:\n        timeline.setStepped(frame);\n        break;\n      case CURVE_BEZIER:\n        setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);\n        setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);\n    }\n    time = time2;\n    value1 = nvalue1;\n    value2 = nvalue2;\n  }\n  return timeline;\n}\nfunction setBezier(input, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {\n  timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);\n}\nconst BONE_ROTATE = 0;\nconst BONE_TRANSLATE = 1;\nconst BONE_TRANSLATEX = 2;\nconst BONE_TRANSLATEY = 3;\nconst BONE_SCALE = 4;\nconst BONE_SCALEX = 5;\nconst BONE_SCALEY = 6;\nconst BONE_SHEAR = 7;\nconst BONE_SHEARX = 8;\nconst BONE_SHEARY = 9;\nconst SLOT_ATTACHMENT = 0;\nconst SLOT_RGBA = 1;\nconst SLOT_RGB = 2;\nconst SLOT_RGBA2 = 3;\nconst SLOT_RGB2 = 4;\nconst SLOT_ALPHA = 5;\nconst ATTACHMENT_DEFORM = 0;\nconst ATTACHMENT_SEQUENCE = 1;\nconst PATH_POSITION = 0;\nconst PATH_SPACING = 1;\nconst PATH_MIX = 2;\nconst CURVE_STEPPED = 1;\nconst CURVE_BEZIER = 2;\n\nexport { SkeletonBinary };\n//# sourceMappingURL=SkeletonBinary.mjs.map\n"],"names":["BLEND_MODES"],"mappings":";;;;;AA09BiC,CAACA,qBAAW,CAAC,MAAM,EAAEA,qBAAW,CAAC,GAAG,EAAEA,qBAAW,CAAC,QAAQ,EAAEA,qBAAW,CAAC,MAAM,CAAC;;"}