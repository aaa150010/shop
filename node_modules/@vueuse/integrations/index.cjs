'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vueDemi = require('vue-demi');
var axios = require('axios');
var shared = require('@vueuse/shared');
var Cookie = require('universal-cookie');
var drauu = require('drauu');
var core = require('@vueuse/core');
var focusTrap = require('focus-trap');
var Fuse = require('fuse.js');
var jwt_decode = require('jwt-decode');
var nprogress = require('nprogress');
var QRCode = require('qrcode');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
var Cookie__default = /*#__PURE__*/_interopDefaultLegacy(Cookie);
var Fuse__default = /*#__PURE__*/_interopDefaultLegacy(Fuse);
var jwt_decode__default = /*#__PURE__*/_interopDefaultLegacy(jwt_decode);
var nprogress__default = /*#__PURE__*/_interopDefaultLegacy(nprogress);
var QRCode__default = /*#__PURE__*/_interopDefaultLegacy(QRCode);

var __defProp$3 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
function useAxios(url, ...args) {
  let defaultConfig = {};
  let instance = axios__default["default"];
  let options = { immediate: true };
  if (args.length > 0) {
    if ("request" in args[0])
      instance = args[0];
    else
      defaultConfig = args[0];
  }
  if (args.length > 1) {
    if ("request" in args[1])
      instance = args[1];
  }
  if (args.length >= 2)
    options = args[args.length - 1];
  const response = vueDemi.shallowRef();
  const data = vueDemi.shallowRef();
  const isFinished = vueDemi.ref(false);
  const isLoading = vueDemi.ref(false);
  const aborted = vueDemi.ref(false);
  const error = vueDemi.shallowRef();
  const cancelToken = axios__default["default"].CancelToken.source();
  const abort = (message) => {
    if (isFinished.value || !isLoading.value)
      return;
    cancelToken.cancel(message);
    aborted.value = true;
    isLoading.value = false;
    isFinished.value = false;
  };
  const loading = (loading2) => {
    isLoading.value = loading2;
    isFinished.value = !loading2;
  };
  const execute = (config = {}) => {
    loading(true);
    instance(url, __spreadProps$1(__spreadValues$3(__spreadValues$3({}, defaultConfig), config), { cancelToken: cancelToken.token })).then((r) => {
      response.value = r;
      data.value = r.data;
    }).catch((e) => {
      error.value = e;
    }).finally(() => {
      loading(false);
    });
  };
  if (options.immediate)
    execute();
  return {
    response,
    data,
    error,
    finished: isFinished,
    loading: isLoading,
    isFinished,
    isLoading,
    cancel: abort,
    canceled: aborted,
    aborted,
    abort,
    execute
  };
}

var __defProp$2 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
function createCookies(req) {
  const universalCookie = new Cookie__default["default"](req ? req.headers.cookie : null);
  return (dependencies, { doNotParse = false, autoUpdateDependencies = false } = {}) => useCookies(dependencies, { doNotParse, autoUpdateDependencies }, universalCookie);
}
function useCookies(dependencies, { doNotParse = false, autoUpdateDependencies = false } = {}, cookies = new Cookie__default["default"]()) {
  const watchingDependencies = autoUpdateDependencies ? [...dependencies || []] : dependencies;
  let previousCookies = cookies.getAll({ doNotParse: true });
  const touches = vueDemi.ref(0);
  const onChange = () => {
    const newCookies = cookies.getAll({ doNotParse: true });
    if (shouldUpdate(watchingDependencies || null, newCookies, previousCookies))
      touches.value++;
    previousCookies = newCookies;
  };
  cookies.addChangeListener(onChange);
  shared.tryOnScopeDispose(() => {
    cookies.removeChangeListener(onChange);
  });
  return {
    get: (...args) => {
      if (autoUpdateDependencies && watchingDependencies && !watchingDependencies.includes(args[0]))
        watchingDependencies.push(args[0]);
      touches.value;
      return cookies.get(args[0], __spreadValues$2({ doNotParse }, args[1]));
    },
    getAll: (...args) => {
      touches.value;
      return cookies.getAll(__spreadValues$2({ doNotParse }, args[0]));
    },
    set: (...args) => cookies.set(...args),
    remove: (...args) => cookies.remove(...args),
    addChangeListener: (...args) => cookies.addChangeListener(...args),
    removeChangeListener: (...args) => cookies.removeChangeListener(...args)
  };
}
function shouldUpdate(dependencies, newCookies, oldCookies) {
  if (!dependencies)
    return true;
  for (const dependency of dependencies) {
    if (newCookies[dependency] !== oldCookies[dependency])
      return true;
  }
  return false;
}

var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
function useDrauu(target, options) {
  const drauuInstance = vueDemi.ref();
  let disposables = [];
  const onChangedHook = core.createEventHook();
  const onCanceledHook = core.createEventHook();
  const onCommittedHook = core.createEventHook();
  const onStartHook = core.createEventHook();
  const onEndHook = core.createEventHook();
  const canUndo = vueDemi.ref(false);
  const canRedo = vueDemi.ref(false);
  const altPressed = vueDemi.ref(false);
  const shiftPressed = vueDemi.ref(false);
  const brush = vueDemi.ref({
    color: "black",
    size: 3,
    arrowEnd: false,
    cornerRadius: 0,
    dasharray: void 0,
    fill: "transparent",
    mode: "draw"
  });
  vueDemi.watch(brush, () => {
    const instance = drauuInstance.value;
    if (instance)
      instance.brush = brush.value;
  }, { deep: true });
  const undo = () => {
    var _a;
    return (_a = drauuInstance.value) == null ? void 0 : _a.undo();
  };
  const redo = () => {
    var _a;
    return (_a = drauuInstance.value) == null ? void 0 : _a.redo();
  };
  const clear = () => {
    var _a;
    return (_a = drauuInstance.value) == null ? void 0 : _a.clear();
  };
  const cancel = () => {
    var _a;
    return (_a = drauuInstance.value) == null ? void 0 : _a.cancel();
  };
  const load = (svg) => {
    var _a;
    return (_a = drauuInstance.value) == null ? void 0 : _a.load(svg);
  };
  const dump = () => {
    var _a;
    return (_a = drauuInstance.value) == null ? void 0 : _a.dump();
  };
  const cleanup = () => {
    var _a;
    disposables.forEach((dispose) => dispose());
    (_a = drauuInstance.value) == null ? void 0 : _a.unmount();
  };
  const syncStatus = () => {
    if (drauuInstance.value) {
      canUndo.value = drauuInstance.value.canUndo();
      canRedo.value = drauuInstance.value.canRedo();
      altPressed.value = drauuInstance.value.altPressed;
      shiftPressed.value = drauuInstance.value.shiftPressed;
    }
  };
  vueDemi.watch(() => core.unrefElement(target), (el) => {
    if (!el || typeof SVGSVGElement === "undefined" || !(el instanceof SVGSVGElement))
      return;
    if (drauuInstance.value)
      cleanup();
    drauuInstance.value = drauu.createDrauu(__spreadValues$1({ el }, options));
    syncStatus();
    disposables = [
      drauuInstance.value.on("canceled", () => onCanceledHook.trigger()),
      drauuInstance.value.on("committed", () => onCommittedHook.trigger()),
      drauuInstance.value.on("start", () => onStartHook.trigger()),
      drauuInstance.value.on("end", () => onEndHook.trigger()),
      drauuInstance.value.on("changed", () => {
        syncStatus();
        onChangedHook.trigger();
      })
    ];
  }, { flush: "post" });
  shared.tryOnScopeDispose(() => cleanup());
  return {
    drauuInstance,
    load,
    dump,
    clear,
    cancel,
    undo,
    redo,
    canUndo,
    canRedo,
    brush,
    onChanged: onChangedHook.on,
    onCommitted: onCommittedHook.on,
    onStart: onStartHook.on,
    onEnd: onEndHook.on,
    onCanceled: onCanceledHook.on
  };
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useFocusTrap(target, options = {}) {
  let trap;
  const _a = options, { immediate } = _a, focusTrapOptions = __objRest(_a, ["immediate"]);
  const hasFocus = vueDemi.ref(false);
  const isPaused = vueDemi.ref(false);
  const activate = (opts) => trap && trap.activate(opts);
  const deactivate = (opts) => trap && trap.deactivate(opts);
  const pause = () => {
    if (trap) {
      trap.pause();
      isPaused.value = true;
    }
  };
  const unpause = () => {
    if (trap) {
      trap.unpause();
      isPaused.value = false;
    }
  };
  vueDemi.watch(() => core.unrefElement(target), (el) => {
    if (!el)
      return;
    trap = focusTrap.createFocusTrap(el, __spreadProps(__spreadValues({}, focusTrapOptions), {
      onActivate() {
        hasFocus.value = true;
        if (options.onActivate)
          options.onActivate();
      },
      onDeactivate() {
        hasFocus.value = false;
        if (options.onDeactivate)
          options.onDeactivate();
      }
    }));
    if (immediate)
      activate();
  }, { flush: "post" });
  core.tryOnScopeDispose(() => deactivate());
  return {
    hasFocus,
    isPaused,
    activate,
    deactivate,
    pause,
    unpause
  };
}

function useFuse(search, data, options) {
  var _a;
  const createFuse = (data2, options2) => {
    var _a2;
    const _options = options2;
    return new Fuse__default["default"]((_a2 = vueDemi.unref(data2)) != null ? _a2 : [], _options);
  };
  const fuse = vueDemi.ref(createFuse(data, (_a = vueDemi.unref(options)) == null ? void 0 : _a.fuseOptions));
  vueDemi.watch(() => {
    var _a2;
    return (_a2 = vueDemi.unref(options)) == null ? void 0 : _a2.fuseOptions;
  }, (newOptions) => {
    fuse.value = createFuse(data, newOptions);
  }, { deep: true });
  vueDemi.watch(() => vueDemi.unref(data), (newData) => {
    fuse.value.setCollection(newData);
  }, { deep: true });
  const results = vueDemi.computed(() => {
    var _a2, _b;
    if (((_a2 = vueDemi.unref(options)) == null ? void 0 : _a2.matchAllWhenSearchEmpty) && !vueDemi.unref(search))
      return vueDemi.unref(data).map((item, index) => ({ item, refIndex: index }));
    const limit = (_b = vueDemi.unref(options)) == null ? void 0 : _b.resultLimit;
    return fuse.value.search(vueDemi.unref(search), limit ? { limit } : void 0);
  });
  return {
    results
  };
}

function useJwt(encodedJwt, options = {}) {
  const encodedJwtRef = vueDemi.ref(encodedJwt);
  const {
    onError,
    fallbackValue = null
  } = options;
  const decodeWithFallback = (encodedJwt2, options2) => {
    try {
      return jwt_decode__default["default"](encodedJwt2, options2);
    } catch (err) {
      onError == null ? void 0 : onError(err);
      return fallbackValue;
    }
  };
  const header = vueDemi.computed(() => decodeWithFallback(encodedJwtRef.value, { header: true }));
  const payload = vueDemi.computed(() => decodeWithFallback(encodedJwtRef.value));
  return {
    header,
    payload
  };
}

function useNProgress(currentProgress = null, options) {
  const progress = vueDemi.isRef(currentProgress) ? currentProgress : vueDemi.ref(currentProgress);
  const isLoading = vueDemi.computed({
    set: (load) => load ? nprogress__default["default"].start() : nprogress__default["default"].done(),
    get: () => shared.isNumber(progress.value) && progress.value < 1
  });
  if (options)
    nprogress__default["default"].configure(options);
  const setProgress = nprogress__default["default"].set;
  nprogress__default["default"].set = (n) => {
    progress.value = n;
    return setProgress.call(nprogress__default["default"], n);
  };
  vueDemi.watchEffect(() => {
    if (shared.isNumber(progress.value))
      setProgress.call(nprogress__default["default"], progress.value);
  });
  shared.tryOnScopeDispose(nprogress__default["default"].remove);
  return {
    isLoading,
    progress,
    start: nprogress__default["default"].start,
    done: nprogress__default["default"].done,
    remove: () => {
      progress.value = null;
      nprogress__default["default"].remove();
    }
  };
}

function useQRCode(text, options) {
  const src = vueDemi.ref(text);
  const result = vueDemi.ref("");
  vueDemi.watch(src, async (value) => {
    if (src.value && shared.isClient)
      result.value = await QRCode__default["default"].toDataURL(value, options);
  }, { immediate: true });
  return result;
}

exports.createCookies = createCookies;
exports.useAxios = useAxios;
exports.useCookies = useCookies;
exports.useDrauu = useDrauu;
exports.useFocusTrap = useFocusTrap;
exports.useFuse = useFuse;
exports.useJwt = useJwt;
exports.useNProgress = useNProgress;
exports.useQRCode = useQRCode;
